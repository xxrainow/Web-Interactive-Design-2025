<!DOCTYPE html>
<html lang="ko">
  <head>
    <script>
      (function (d) {
        var config = {
            kitId: 'wxq3dyk',
            scriptTimeout: 3000,
            async: true,
          },
          h = d.documentElement,
          t = setTimeout(function () {
            h.className =
              h.className.replace(/\bwf-loading\b/g, '') + ' wf-inactive';
          }, config.scriptTimeout),
          tk = d.createElement('script'),
          f = false,
          s = d.getElementsByTagName('script')[0],
          a;
        h.className += ' wf-loading';
        tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
        tk.async = true;
        tk.onload = tk.onreadystatechange = function () {
          a = this.readyState;
          if (f || (a && a != 'complete' && a != 'loaded')) return;
          f = true;
          clearTimeout(t);
          try {
            Typekit.load(config);
          } catch (e) {}
        };
        s.parentNode.insertBefore(tk, s);
      })(document);
    </script>
    <!-- html2canvas (DOM 캡쳐용) -->
    <script
      src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"
      defer
    ></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>케이크</title>
    <style>
      :root {
        /* 어디서부터 노랑으로 바꿀지 (예: 70vh 지점) */
        --split-at: 75vh;
        /* 원하는 노랑색 */
        --bottom-color: #fff5b8;
      }

      body {
        background: linear-gradient(
            to bottom,
            transparent 0 var(--split-at),
            var(--bottom-color) var(--split-at) 100%
          ),
          #fff7f9; /* 기존 위쪽 색 */
        background-repeat: no-repeat;
        background-attachment: fixed, fixed;
        height: 100vh;
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: 'timeline-210', sans-serif;
      }

      /* 페이지 로드시 페이드인용 오버레이 */
      #pageFade {
        position: fixed;
        inset: 0;
        background: #fff7f9; /* 초기 배경색과 동일하게 */
        z-index: 9999;
        pointer-events: none; /* 인터랙션 방해 X */
        opacity: 1; /* 처음엔 가득 덮여 있음 */
        transition: opacity 1000ms ease;
      }
      /* 사라질 때 */
      #pageFade.fade-out {
        opacity: 0;
      }

      /* 모션 최소화 환경 대응 */
      @media (prefers-reduced-motion: reduce) {
        #pageFade {
          transition: none;
          opacity: 0;
        }
      }

      /* 공통 */
      img {
        user-select: none;
      }
      /* 케이크 */
      #cake {
        position: absolute;
        bottom: 110px;
        left: 50%;
        transform: translateX(-50%);
        width: 800px;
      }
      /* 초에 붙는 불 (초 불꽃) */
      #candle-flame {
        position: absolute;
        left: 50%;
        --fx: -125px; /* X: 왼쪽(-), 오른쪽(+) */
        --fy: -60px; /* Y: 위(-), 아래(+) */
        transform: translate(var(--fx), var(--fy));
        width: 40px;
        display: none;
        pointer-events: none;
      }
      /* 성냥곽 (고정) */
      #matchbox-hand {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 400px;
      }
      /* 성냥 (드래그 가능) */
      #match-hand {
        position: absolute;
        bottom: 0;
        right: 0;
        width: 600px;
        cursor: grab;
      }
      /* 성냥 불 */
      #flame {
        position: absolute;
        width: 30px;
        left: 400px;
        display: none;
        pointer-events: none;

        --fx: -50px; /* X: 왼쪽(-), 오른쪽(+) */
        --fy: 12px; /* Y: 위(-), 아래(+) */
        transform: translate(var(--fx), var(--fy));
      }

      /* 안내 문구 */
      #hint {
        position: absolute;
        top: 40px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 22px;
        color: #ff6f91;
        background: #fff;
        padding: 16px 50px;
        border-radius: 10px;
        border: 1px solid rgba(255, 111, 145, 1);
        box-shadow: 2px 3px 0px rgba(255, 111, 145, 1);
      }

      /* 불꽃 공통: 기준 오프셋 + 흔들림 + 스케일을 합성 */
      #flame,
      #candle-flame {
        /* 기존 보정(이미 #flame에 --fx/--fy 있음) + 추가 보정(--tx/--ty) */
        --tx: 0px; /* candle-flame용 위치 미세 보정 */
        --ty: 0px;

        /* 흔들림/스케일 변수 */
        --jx: 0px;
        --jy: 0px;
        --s: 1;

        /* 합성: 기존 translate → 추가보정 → 흔들림 → 스케일 */
        transform: translate(var(--fx, 0px), var(--fy, 0px))
          translate(var(--tx), var(--ty)) translate(var(--jx), var(--jy))
          scale(var(--s));
        transform-origin: 50% 80%;
        filter: drop-shadow(0 0 8px rgba(255, 160, 0, 0.55));
        will-change: transform, filter; /* 부드럽게 */
      }

      /* 점화 시 붙일 클래스 */
      .flicker {
        animation: flame-flicker 100ms infinite alternate ease-in-out;
      }

      /* 모션 선호 꺼짐 대응 */
      @media (prefers-reduced-motion: reduce) {
        .flicker {
          animation: none;
        }
      }

      /* 키프레임: 스케일 + 살짝 흔들림 + 글로우 강약 */
      @keyframes flame-flicker {
        0% {
          --s: 0.9;
          --jx: -1px;
          --jy: 0px;
          filter: drop-shadow(0 0 6px rgba(255, 180, 0, 0.45));
        }
        100% {
          --s: 1.15;
          --jx: 1px;
          --jy: -0.9px;
          filter: drop-shadow(0 0 12px rgba(255, 200, 0, 0.7));
        }
      }

      /* 배경을 대각선으로 흐르게 하는 애니메이션 */
      @keyframes bg-shift {
        0% {
          background-position: 0% 50%;
        }
        50% {
          background-position: 100% 50%;
        }
        100% {
          background-position: 0% 50%;
        }
      }

      /* 무지개처럼 색상이 계속 변하는 애니메이션 */
      @keyframes rainbow-cycle {
        0% {
          filter: hue-rotate(0deg);
        }
        100% {
          filter: hue-rotate(360deg);
        }
      }

      /* 1초에 한 번씩 밝게 깜빡이는 애니메이션 */
      @keyframes blink-effect {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.6);
        } /* 더 밝게 깜빡이도록 수치 조정 */
      }

      /* 'HAPPY BIRTHDAY' 텍스트 흐름 애니메이션 */
      @keyframes text-scroll {
        from {
          transform: translateX(0);
        }
        to {
          transform: translateX(-50%);
        } /* 텍스트를 2번 반복하여 끊김 없는 효과 */
      }

      /* 촛불이 켜졌을 때 body에 적용될 클래스 */
      body.celebrate {
        --scroll-text: '⋰˚★ HAPPY BIRTHDAY ⛧*̩̩͙⸝⋆ HAPPY BIRTHDAY ★!¡ HAPPY BIRTHDAY ⋰˚✩ HAPPY BIRTHDAY ✩⡱';
        /* 더 화려하고 다채로운 그라데이션 색상 */
        background: linear-gradient(
            120deg,
            rgba(255, 121, 198, 0.95),
            rgba(189, 147, 249, 0.95),
            rgba(255, 184, 108, 0.95),
            rgba(80, 250, 123, 0.95),
            rgba(139, 233, 253, 0.95),
            rgba(255, 85, 85, 0.95),
            rgba(241, 250, 140, 0.95)
          ),
          linear-gradient(
            to bottom,
            transparent 0 var(--split-at),
            var(--bottom-color) var(--split-at) 100%
          ),
          #fff7f9;
        /* 그라데이션이 부드럽게 움직이도록 크기를 크게 설정 */
        background-size: 400% 400%, 100% 100%, 100% 100%;
        background-position: 0% 50%, 0 0, 0 0;
        background-repeat: no-repeat, no-repeat, no-repeat;
        background-blend-mode: hard-light, normal, normal; /* ← 여기! */

        /* 3가지 애니메이션을 동시에 적용 */
        animation: bg-shift 15s ease infinite,
          /* 배경 흐름 */ rainbow-cycle 6s linear infinite,
          /* 색상 변화 */ blink-effect 1s ease-in-out infinite; /* 1초 깜빡임 */
      }

      /* 흐르는 텍스트를 위한 가상 요소 */
      body.celebrate::before {
        content: var(--scroll-text);
        font-family: 'timeline-210', sans-serif;
        position: absolute;
        top: 14%;
        left: 0;
        transform: translateY(-50%);
        width: 400%; /* 끊김 없는 스크롤을 위해 2배 너비 */
        color: rgb(255, 67, 120);
        font-size: 8vw; /* 화면 크기에 반응하는 폰트 */
        font-weight: 800;
        text-transform: uppercase;
        white-space: nowrap; /* 줄바꿈 방지 */
        z-index: -1; /* 다른 콘텐츠 뒤로 보내기 */
        animation: text-scroll 5s linear infinite;
      }

      /* 모션 최소화 환경에서는 깜빡임과 색상 변화를 제거 */
      @media (prefers-reduced-motion: reduce) {
        body.celebrate {
          /* 부드러운 배경 흐름만 유지 */
          animation: bg-shift 15s ease infinite;
        }
      }

      .wishlist-toggle {
        position: fixed;
        right: 40px;
        bottom: 160px;
        z-index: 10000;
        padding: 15px 30px;
        border: none;
        border-radius: 999px;
        background: #ff4d6d;
        color: #fff;
        font-size: 18px;
        font-family: 'timeline-210', sans-serif;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .wishlist-toggle:hover {
        filter: brightness(1.08);
      }

      .wishlist-panel {
        position: fixed;
        right: 40px;
        bottom: 215px; /* 토글 버튼 위로 */
        width: 320px;
        max-height: 60vh;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 14px;
        border-radius: 16px;
        background: #fff;
        border: 1px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.18);
        z-index: 10001;

        /* 기본은 닫힘 상태 (투명 + 약간 아래 + scale) */
        opacity: 0;
        transform: translateY(12px) scale(0.98);
        pointer-events: none;
        transition: opacity 0.22s ease, transform 0.22s ease;
        font-family: 'timeline-210', sans-serif;
      }
      .wishlist-panel.open {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }

      .wl-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .wl-header strong {
        font-size: 1.05rem;
        color: #333;
      }
      .wl-close {
        border: none;
        background: transparent;
        cursor: pointer;
        font-size: 1.05rem;
        line-height: 1;
        color: #888;
      }
      .wl-close:hover {
        color: #111;
      }

      .wl-form {
        display: flex;
        gap: 8px;
      }
      .wl-input {
        flex: 1;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid #e7e7e7;
        font-size: 0.95rem;
      }
      .wl-add {
        padding: 10px 12px;
        border: none;
        border-radius: 10px;
        background: #ff80a4;
        color: #fff;
        cursor: pointer;
      }
      .wl-add:hover {
        filter: brightness(1.05);
      }

      .wishlist-list {
        list-style: none;
        margin: 0;
        padding: 0;
        overflow: auto; /* 스크롤 */
      }
      .wishlist-list li {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px 6px;
        border-bottom: 1px dashed #eee;
      }
      .wishlist-list .wl-text {
        flex: 1;
        word-break: break-word;
      }
      .wishlist-list .wl-del {
        border: none;
        background: transparent;
        cursor: pointer;
        color: #999;
        font-size: 0.95rem;
      }
      .wishlist-list .wl-del:hover {
        color: #ff4d6d;
      }

      .wl-footer {
        display: flex;
        justify-content: flex-end;
      }
      .wl-clear {
        border: none;
        background: transparent;
        cursor: pointer;
        color: #888;
        font-size: 0.9rem;
        text-decoration: underline;
      }
      .wl-clear:hover {
        color: #333;
      }

      /* ===== 💌 Letter panel ===== */
      .letter-toggle {
        position: fixed;
        right: 40px;
        bottom: 100px; /* 위시 토글(20px) 위로 살짝 띄움 */
        z-index: 10000;
        padding: 15px 30px;
        border: none;
        border-radius: 999px;
        background: #ff4d6d;
        color: #fff;
        font-size: 18px;
        font-family: 'timeline-210', sans-serif;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .letter-toggle:hover {
        filter: brightness(1.08);
      }

      .letter-panel {
        position: fixed;
        right: 40px;
        bottom: 155px; /* 토글 버튼 위로 */
        width: 340px;
        max-height: 65vh;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 14px;
        border-radius: 16px;
        background: #fff;
        border: 1px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.18);
        z-index: 10001;

        opacity: 0;
        transform: translateY(12px) scale(0.98);
        pointer-events: none;
        transition: opacity 0.22s ease, transform 0.22s ease;
        font-family: 'timeline-210', sans-serif;
      }
      .letter-panel.open {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }

      .lt-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .lt-header strong {
        font-size: 1.05rem;
        color: #333;
      }
      .lt-close {
        border: none;
        background: transparent;
        cursor: pointer;
        color: #888;
        font-size: 1.05rem;
      }
      .lt-close:hover {
        color: #111;
      }

      .lt-input {
        width: 92%;
        min-height: 220px;
        resize: vertical;
        padding: 12px;
        border-radius: 12px;
        border: 1px solid #e7e7e7;
        font-size: 0.95rem;
        line-height: 1.5;
        outline: none;
      }
      .lt-actions {
        display: flex;
        align-items: center;
        gap: 8px;
        justify-content: space-between;
      }
      .lt-left {
        display: flex;
        gap: 8px;
      }
      .lt-btn {
        padding: 10px 12px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        background: #ff80a4;
        color: #fff;
      }
      .lt-btn.secondary {
        background: #f1f3f5;
        color: #333;
      }
      .lt-btn:hover {
        filter: brightness(1.05);
      }

      .lt-meta {
        font-size: 0.85rem;
        color: #777;
        margin-left: auto;
      }

      /* ===== 오늘을 기억하기 (스크린샷) ===== */
      .memory-toggle {
        position: fixed;
        right: 40px;
        bottom: 40px; /* '나에게 편지 쓰기' 버튼(40px)보다 더 아래 */
        z-index: 10000;
        padding: 15px 30px;
        border: none;
        border-radius: 999px;
        background: #ff4d6d;
        color: #fff;
        font-size: 18px;
        font-family: 'timeline-210', sans-serif;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .memory-toggle:hover {
        filter: brightness(1.08);
      }

      .memory-panel {
        position: fixed;
        right: 40px;
        bottom: 95px;
        width: 340px;
        max-height: 60vh;
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 14px;
        border-radius: 16px;
        background: #fff;
        border: 1px solid rgba(0, 0, 0, 0.08);
        box-shadow: 0 12px 32px rgba(0, 0, 0, 0.18);
        z-index: 10001;
        opacity: 0;
        transform: translateY(12px) scale(0.98);
        pointer-events: none;
        transition: opacity 0.22s ease, transform 0.22s ease;
        font-family: 'timeline-210', sans-serif;
      }
      .memory-panel.open {
        opacity: 1;
        transform: translateY(0) scale(1);
        pointer-events: auto;
      }

      .mem-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .mem-header strong {
        font-size: 1.05rem;
        color: #333;
      }
      .mem-close {
        border: none;
        background: transparent;
        cursor: pointer;
        color: #888;
        font-size: 1.05rem;
      }
      .mem-close:hover {
        color: #111;
      }

      .mem-actions {
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }
      .mem-btn {
        padding: 10px 12px;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        background: #ff80a4;
        color: #fff;
      }
      .mem-btn:hover {
        filter: brightness(1.05);
      }
      .mem-note {
        font-size: 0.85rem;
        color: #777;
        line-height: 1.4;
      }
      .mem-meta {
        font-size: 0.85rem;
        color: #777;
      }

      /* 캡쳐 직전 일시 숨김에 사용 */
      .capture-hide {
        visibility: hidden !important;
      }

      /* =====  BGM 토글 버튼 ===== */
      .bgm-toggle {
        position: fixed;
        right: 20px;
        top: 30px;
        z-index: 99;
        padding: 10px 14px;
        border: none;
        border-radius: 999px;
        background: #222;
        color: #fff;
        font-size: 0.95rem;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        font-family: 'timeline-210', sans-serif;
      }
      .bgm-toggle:hover {
        filter: brightness(1.1);
      }
    </style>
  </head>
  <body>
    <div id="pageFade" aria-hidden="true"></div>

    <div>
      <div id="hint">성냥을 성냥곽 쪽으로 문질러 보세요 🔥</div>
      <img draggable="false" id="cake" src="images/cake.png" alt="케이크" />
      <img
        draggable="false"
        id="matchbox-hand"
        src="images/matchbox.png"
        alt="성냥곽을 든 손"
      />
      <!-- 케이크 위 초 불 이미지 -->
      <img
        draggable="false"
        id="candle-flame"
        src="images/flame.png"
        alt="초 불꽃"
      />
      <img
        draggable="false"
        id="match-hand"
        src="images/match.png"
        alt="성냥을 든 손"
      />
      <img draggable="false" id="flame" src="images/flame.png" alt="불꽃" />

      <!--  배경 음악 -->
      <audio id="birthdaybgm" preload="auto" loop>
        <source src="bgm/birthdaybgm.wav" type="audio/wav" />
      </audio>
      <audio id="firebgm" preload="auto">
        <source src="bgm/fire.mp3" type="audio/mp3" />
      </audio>
      <audio id="firingbgm" preload="auto" loop>
        <source src="bgm/firing.mp3" type="audio/mp3" />
      </audio>

      <button
        id="wishlist-toggle"
        class="wishlist-toggle"
        aria-haspopup="dialog"
        aria-expanded="false"
        aria-controls="wishlist-panel"
      >
        위시리스트
      </button>

      <!-- 위시리스트 패널 -->
      <div
        id="wishlist-panel"
        class="wishlist-panel"
        role="dialog"
        aria-modal="false"
        aria-labelledby="wishlist-title"
      >
        <div class="wl-header">
          <strong id="wishlist-title">위시리스트</strong>
          <button type="button" class="wl-close" aria-label="닫기">✕</button>
        </div>

        <form id="wishlist-form" class="wl-form" autocomplete="off">
          <input
            id="wishlist-input"
            class="wl-input"
            type="text"
            placeholder="원하는 걸 적어보세요 (Enter)"
          />
          <button type="submit" class="wl-add">추가</button>
        </form>

        <ul id="wishlist-list" class="wishlist-list" aria-live="polite"></ul>

        <div class="wl-footer">
          <button id="wishlist-clear" type="button" class="wl-clear">
            전체 삭제
          </button>
        </div>
      </div>

      <!-- 편지 토글 버튼 -->
      <button
        id="letter-toggle"
        class="letter-toggle"
        aria-haspopup="dialog"
        aria-expanded="false"
        aria-controls="letter-panel"
      >
        나에게 편지 쓰기
      </button>

      <!-- 편지 패널 -->
      <div
        id="letter-panel"
        class="letter-panel"
        role="dialog"
        aria-modal="false"
        aria-labelledby="letter-title"
      >
        <div class="lt-header">
          <strong id="letter-title">나에게 쓰는 편지</strong>
          <button type="button" class="lt-close" aria-label="닫기">✕</button>
        </div>

        <textarea
          id="letter-textarea"
          class="lt-input"
          placeholder="오늘의 하루를 적어보세요..."
        ></textarea>

        <div class="lt-actions">
          <div class="lt-left">
            <button id="letter-save" class="lt-btn" type="button">저장</button>
            <button id="letter-download" class="lt-btn secondary" type="button">
              TXT로 다운
            </button>
            <button id="letter-clear" class="lt-btn secondary" type="button">
              전체 삭제
            </button>
          </div>
          <span id="letter-meta" class="lt-meta" aria-live="polite"></span>
        </div>
      </div>
      <!-- 오늘을 기억하기: 토글 버튼 -->
      <button
        id="memory-toggle"
        class="memory-toggle"
        aria-haspopup="dialog"
        aria-expanded="false"
        aria-controls="memory-panel"
      >
        오늘을 기억하기
      </button>

      <!-- 오늘을 기억하기: 패널 -->
      <div
        id="memory-panel"
        class="memory-panel"
        role="dialog"
        aria-modal="false"
        aria-labelledby="memory-title"
      >
        <div class="mem-header">
          <strong id="memory-title">오늘을 기억하기</strong>
          <button type="button" class="mem-close" aria-label="닫기">✕</button>
        </div>

        <div class="mem-actions">
          <button id="mem-capture" class="mem-btn" type="button">
            화면 캡쳐 (PNG)
          </button>
        </div>
        <p class="mem-note">TIP: 패널/버튼은 캡쳐에서 자동 제외돼요.</p>
        <span id="mem-meta" class="mem-meta" aria-live="polite"></span>
      </div>

      <button
        id="bgm-toggle"
        class="bgm-toggle"
        aria-pressed="false"
        aria-label="배경음악 켜기/끄기"
      >
        BGM 켜기
      </button>
    </div>
    <script>
      // 모든 리소스(이미지 등) 다 로드된 뒤 페이드아웃
      function runPageFadeIn() {
        const overlay = document.getElementById('pageFade');
        if (!overlay) return;
        // 다음 프레임에서 클래스를 바꿔야 전환이 확실히 걸림
        requestAnimationFrame(() => {
          overlay.classList.add('fade-out');
          overlay.addEventListener('transitionend', () => overlay.remove(), {
            once: true,
          });
        });
      }
      if (document.readyState === 'complete') {
        runPageFadeIn(); // 캐시로 이미 로드된 경우
      } else {
        window.addEventListener('load', runPageFadeIn); // 일반적인 경우
      }

      const match = document.getElementById('match-hand');
      const matchbox = document.getElementById('matchbox-hand');
      const cake = document.getElementById('cake');
      const flame = document.getElementById('flame');
      const candleFlame = document.getElementById('candle-flame');
      const hint = document.getElementById('hint');

      let isDragging = false;
      let hasFire = false;
      let candleLit = false;
      // (오류 방지용) 오디오 프라이밍 플래그
      let birthdayBgmPrimed = false;

      // 마우스 기준 성냥 '끝' 좌표 보정값(px)
      // flame이 (e.pageX-40, e.pageY-120) + CSS translate(-50px, +12px)
      const TIP_DX = -90; // 왼(-) / 오(+)
      const TIP_DY = -108; // 위(-) / 아래(+)

      // 성냥곽 내부 핫스팟 비율 (x, y, w, h)
      const HOTSPOT = { x: 0.6, y: 0.35, w: 0.2, h: 0.15 };
      // 케이크 위 초 위치 비율 (x, y, w, h)
      const CANDLE_SPOTS = [
        { x: 0.5, y: 0, w: 0.3, h: 0.1 }, // 가운데 초 근처(예시값)
        // { x: 0.44, y: 0.18, w: 0.03, h: 0.06 }, // 왼쪽 초 (필요시)
        // { x: 0.56, y: 0.18, w: 0.03, h: 0.06 }, // 오른쪽 초 (필요시)
      ];

      // 포인터(마우스) 기준 '성냥 끝'의 화면 좌표
      function getMatchTipPoint(e) {
        return { x: e.pageX + TIP_DX, y: e.pageY + TIP_DY };
      }

      // 성냥곽 내부 '핫스팟'의 화면상 사각형(px)
      function getHotspotRect() {
        const r = matchbox.getBoundingClientRect();
        return {
          left: r.left + r.width * HOTSPOT.x,
          top: r.top + r.height * HOTSPOT.y,
          right: r.left + r.width * (HOTSPOT.x + HOTSPOT.w),
          bottom: r.top + r.height * (HOTSPOT.y + HOTSPOT.h),
        };
      }

      // 케이크 위 초 위치들의 화면상 사각형(px) 배열
      function getCandleRects() {
        const r = cake.getBoundingClientRect();
        return CANDLE_SPOTS.map((s) => ({
          left: r.left + r.width * s.x,
          top: r.top + r.height * s.y,
          right: r.left + r.width * (s.x + s.w),
          bottom: r.top + r.height * (s.y + s.h),
        }));
      }

      // 겹침 확인 함수
      function isOverlap(a, b) {
        const r1 = a.getBoundingClientRect();
        const r2 = b.getBoundingClientRect();
        return !(
          r1.right < r2.left ||
          r1.left > r2.right ||
          r1.bottom < r2.top ||
          r1.top > r2.bottom
        );
      }

      /* ============================
       * 드래그 & 인터랙션
       * ============================ */

      match.addEventListener('mousedown', (e) => {
        isDragging = true;
        match.style.cursor = 'grabbing';

        // 첫 사용자 제스처에서 오디오 미리 활성화(무음 재생)
        if (!birthdayBgmPrimed) {
          try {
            birthdaybgm.volume = 0;
            birthdaybgm
              .play()
              .then(() => {
                birthdayBgmPrimed = true;
              })
              .catch(() => {
                /* 정책으로 막히면 나중에 재시도 */
              });
          } catch {}
        }
      });

      // 드래그 이동
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        // 성냥이 마우스 위치를 따라 이동
        match.style.left = `${e.pageX - 80}px`;
        match.style.top = `${e.pageY - 60}px`;

        // 불꽃이 성냥에 따라 이동
        flame.style.left = `${e.pageX - 40}px`;
        flame.style.top = `${e.pageY - 120}px`;

        if (!hasFire) checkIgnite(e);
        if (hasFire && !candleLit) checkCandleOverlap(e);
      });

      // 드래그 종료
      document.addEventListener('mouseup', () => {
        isDragging = false;
        match.style.cursor = 'grab';
      });

      /* ============================
       * 점화 로직
       * ============================ */

      function checkIgnite(e) {
        const tip = getMatchTipPoint(e);
        const hs = getHotspotRect();
        const inside =
          tip.x >= hs.left &&
          tip.x <= hs.right &&
          tip.y >= hs.top &&
          tip.y <= hs.bottom;

        if (inside) ignite();
      }

      function ignite() {
        if (hasFire) return;
        hasFire = true;
        flame.style.display = 'block';
        flame.classList.add('flicker'); // ← 애니메이션 시작
        hint.textContent = '성냥에 불이 붙었어요! 이제 초에 가져가세요 🕯️';
      }

      // 2. 불 붙은 성냥이 케이크 s위 초 근처로 가면 초에 불 켜기
      function checkCandleOverlap(e) {
        const tip = getMatchTipPoint(e);
        const spots = getCandleRects();

        for (const rect of spots) {
          const inside =
            tip.x >= rect.left &&
            tip.x <= rect.right &&
            tip.y >= rect.top &&
            tip.y <= rect.bottom;
          if (inside) {
            lightCandleAt(rect);
            break;
          }
        }

        try {
          firebgm.volume = 1; // 원하는 볼륨
          firebgm.play().catch(() => {}); // 정책으로 막히면 catch
          firingbgm.volume = 1;
          firingbgm.play().catch(() => {}); // 정책으로 막히면 catch
        } catch {}
      }

      // 촛불 이미지 위치를 핫스팟 위로 정렬
      function lightCandleAt(rect) {
        if (candleLit) return;

        // 핫스팟 상단 중앙에 맞추어 배치
        const cx = (rect.left + rect.right) / 2;
        const cy = rect.top;

        candleFlame.style.display = 'block';
        candleFlame.style.left = `${cx}px`;
        candleFlame.style.top = `${cy}px`;

        // 중앙 정렬/미세보정은 CSS 변수로 (transform 덮어쓰지 않기!)
        candleFlame.style.setProperty('--tx', '-15px');
        candleFlame.style.setProperty('--ty', '-2px');

        candleFlame.classList.add('flicker'); // ← 애니메이션 시작

        candleLit = true;
        hint.textContent = buildCongrats();
        document.body.classList.add('celebrate');
        // 페이드인 없이 즉시 재생
        try {
          birthdaybgm.volume = 0.6; // 원하는 볼륨
          birthdaybgm.play().catch(() => {}); // 정책으로 막히면 catch
          startbgm.pause();
          startbgm.currentTime = 0;
        } catch {}
      }

      /* ============================
       * URL 파라미터 읽기 & 축하 문구 만들기
       * ============================ */
      // --- URL 파라미터(name, age) 읽기 ---
      let userName = '';
      let userAge = '';

      (() => {
        const p = new URLSearchParams(window.location.search);
        const n = (p.get('name') || '').trim();
        const a = (p.get('age') || '').trim();
        const ageNum = parseInt(a, 10);
        if (n) userName = n;
        if (!Number.isNaN(ageNum) && ageNum > 0) userAge = String(ageNum);
      })();

      // --- 축하 문구 만들기 ---
      function buildCongrats() {
        if (userName && userAge)
          return `${userName}님 ${userAge}번째 생일을 축하합니다! 🎉`;
        if (userName) return `${userName}님, 생일을 축하합니다! 🎉`;
        if (userAge) return `${userAge}번째 생일을 축하합니다! 🎉`;
        return '생일을 축하합니다! 🎉';
      }

      // ::before content에 들어갈 스크롤 문구 만들기
      (function () {
        const base =
          '⋰˚★ HAPPY BIRTHDAY ⛧*̩̩͙⸝⋆ HAPPY BIRTHDAY ★!¡ HAPPY BIRTHDAY ⋰˚✩ HAPPY BIRTHDAY ✩⡱';

        const rawName = (userName ?? '').trim();
        // 첫 글자 제거 (문자 단위: 이모지 등 포함 안전)
        const nameTail = rawName ? Array.from(rawName).slice(1).join('') : '';
        const scroll = userName
          ? `HAPPY BIRTHDAY ⋰˚★ ${nameTail}! ${userAge}번째 생일을 진심으로 축하해! ⛧*̩̩͙⸝⋆ HAPPY BIRTHDAY ★!¡ HAPPY BIRTHDAY ⋰˚✩ HAPPY BIRTHDAY ✩⡱`
          : base;

        // content에 쓰이는 CSS 변수는 반드시 “따옴표 포함된 문자열” 로 넣어야 함
        document.body.style.setProperty('--scroll-text', `"${scroll}"`);
      })();

      // ===== Wishlist logic =====
      (() => {
        const KEY = 'hb_wishlist_v1';

        const $toggle = document.getElementById('wishlist-toggle');
        const $panel = document.getElementById('wishlist-panel');
        const $form = document.getElementById('wishlist-form');
        const $input = document.getElementById('wishlist-input');
        const $list = document.getElementById('wishlist-list');
        const $clear = document.getElementById('wishlist-clear');
        const $close = $panel.querySelector('.wl-close');

        let items = [];

        function load() {
          try {
            const raw = localStorage.getItem(KEY);
            items = raw ? JSON.parse(raw) : [];
          } catch {
            items = [];
          }
          render();
        }
        function save() {
          try {
            localStorage.setItem(KEY, JSON.stringify(items));
          } catch {}
        }
        function render() {
          $list.innerHTML = '';
          if (!items.length) {
            const empty = document.createElement('li');
            empty.style.color = '#999';
            empty.textContent = '아직 항목이 없어요.';
            $list.appendChild(empty);
            return;
          }
          items.forEach((text, i) => {
            const li = document.createElement('li');
            const span = document.createElement('span');
            span.className = 'wl-text';
            span.textContent = text;

            const del = document.createElement('button');
            del.className = 'wl-del';
            del.type = 'button';
            del.setAttribute('aria-label', `삭제: ${text}`);
            del.textContent = '삭제';

            del.addEventListener('click', (e) => {
              e.stopPropagation();
              items.splice(i, 1);
              save();
              render();
            });

            li.appendChild(span);
            li.appendChild(del);
            $list.appendChild(li);
          });
        }

        function openPanel() {
          $panel.classList.add('open');
          $toggle.setAttribute('aria-expanded', 'true');
          // 열릴 때 입력창 포커스
          setTimeout(() => $input.focus(), 60);
        }
        function closePanel() {
          $panel.classList.remove('open');
          $toggle.setAttribute('aria-expanded', 'false');
        }
        function togglePanel() {
          if ($panel.classList.contains('open')) closePanel();
          else openPanel();
        }

        // 이벤트 바인딩
        $toggle.addEventListener('click', (e) => {
          e.stopPropagation();
          togglePanel();
        });
        $close.addEventListener('click', (e) => {
          e.stopPropagation();
          closePanel();
        });

        // 폼 제출(추가)
        $form.addEventListener('submit', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const text = $input.value.trim();
          if (!text) return;
          items.unshift(text);
          $input.value = '';
          save();
          render();
        });

        // 전체 삭제
        $clear.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!items.length) return;
          if (confirm('모든 위시 항목을 삭제할까요?')) {
            items = [];
            save();
            render();
          }
        });

        // ESC 닫기
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && $panel.classList.contains('open'))
            closePanel();
        });

        // 바깥 클릭 시 닫기
        document.addEventListener('click', (e) => {
          if (!$panel.classList.contains('open')) return;
          const inside =
            e.target === $panel ||
            $panel.contains(e.target) ||
            e.target === $toggle;
          if (!inside) closePanel();
        });

        // 패널 내부는 버블 막기 (다른 전역 클릭 핸들러와 충돌 방지)
        $panel.addEventListener('click', (e) => e.stopPropagation());

        // 초기 로드
        load();
      })();

      // ===== Letter panel logic =====
      (() => {
        const KEY = 'hb_letter_v1';

        const $toggle = document.getElementById('letter-toggle');
        const $panel = document.getElementById('letter-panel');
        const $close = $panel.querySelector('.lt-close');
        const $ta = document.getElementById('letter-textarea');
        const $save = document.getElementById('letter-save');
        const $dl = document.getElementById('letter-download');
        const $clear = document.getElementById('letter-clear');
        const $meta = document.getElementById('letter-meta');

        // 위시 패널이 열려 있으면 닫아주기(겹침 방지)
        function closeWishlistIfOpen() {
          const wlPanel = document.getElementById('wishlist-panel');
          const wlToggle = document.getElementById('wishlist-toggle');
          if (wlPanel && wlPanel.classList.contains('open')) {
            wlPanel.classList.remove('open');
            if (wlToggle) wlToggle.setAttribute('aria-expanded', 'false');
          }
        }

        // 저장/불러오기
        function load() {
          try {
            const raw = localStorage.getItem(KEY);
            $ta.value = raw || '';
            renderMeta('불러옴');
          } catch {
            $ta.value = '';
            renderMeta('');
          }
        }
        function save() {
          try {
            localStorage.setItem(KEY, $ta.value);
            renderMeta('저장됨');
          } catch {
            renderMeta('저장 실패');
          }
        }
        function renderMeta(text) {
          if (!text) {
            $meta.textContent = '';
            return;
          }
          const now = new Date();
          const hh = String(now.getHours()).padStart(2, '0');
          const mm = String(now.getMinutes()).padStart(2, '0');
          $meta.textContent = `${text} · ${hh}:${mm}`;
        }

        // 자동 저장(입력 후 600ms)
        let tId;
        $ta.addEventListener('input', () => {
          clearTimeout(tId);
          tId = setTimeout(save, 600);
        });

        // 버튼 액션들
        $save.addEventListener('click', save);

        $dl.addEventListener('click', () => {
          const blob = new Blob([$ta.value || ''], {
            type: 'text/plain;charset=utf-8',
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          const d = new Date();
          const y = d.getFullYear(),
            m = String(d.getMonth() + 1).padStart(2, '0'),
            day = String(d.getDate()).padStart(2, '0');
          a.href = url;
          a.download = `my_letter_${y}${m}${day}.txt`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          URL.revokeObjectURL(url);
        });

        $clear.addEventListener('click', () => {
          if (!confirm('편지 내용을 모두 삭제할까요?')) return;
          $ta.value = '';
          try {
            localStorage.removeItem(KEY);
          } catch {}
          renderMeta('삭제됨');
        });

        // 열고 닫기
        function openPanel() {
          closeWishlistIfOpen();
          $panel.classList.add('open');
          $toggle.setAttribute('aria-expanded', 'true');
          setTimeout(() => $ta.focus(), 60);
        }
        function closePanel() {
          $panel.classList.remove('open');
          $toggle.setAttribute('aria-expanded', 'false');
        }
        function togglePanel() {
          if ($panel.classList.contains('open')) closePanel();
          else openPanel();
        }

        $toggle.addEventListener('click', (e) => {
          e.stopPropagation();
          togglePanel();
        });
        $close.addEventListener('click', (e) => {
          e.stopPropagation();
          closePanel();
        });
        $panel.addEventListener('click', (e) => e.stopPropagation());

        // 바깥 클릭 닫기 / ESC 닫기
        document.addEventListener('click', (e) => {
          if ($panel.classList.contains('open')) {
            const inside =
              e.target === $panel ||
              $panel.contains(e.target) ||
              e.target === $toggle;
            if (!inside) closePanel();
          }
        });
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && $panel.classList.contains('open'))
            closePanel();
        });

        // 초기화
        load();
      })();

      // ===== 오늘을 기억하기 (스크린샷 저장) =====
      (() => {
        const $toggle = document.getElementById('memory-toggle');
        const $panel = document.getElementById('memory-panel');
        const $close = $panel.querySelector('.mem-close');
        const $meta = document.getElementById('mem-meta');
        const $capBtn = document.getElementById('mem-capture');

        function setMeta(text) {
          const now = new Date();
          const hh = String(now.getHours()).padStart(2, '0');
          const mm = String(now.getMinutes()).padStart(2, '0');
          $meta.textContent = `${text} · ${hh}:${mm}`;
        }
        function openPanel() {
          $panel.classList.add('open');
          $toggle.setAttribute('aria-expanded', 'true');
        }
        function closePanel() {
          $panel.classList.remove('open');
          $toggle.setAttribute('aria-expanded', 'false');
        }
        function togglePanel() {
          if ($panel.classList.contains('open')) closePanel();
          else openPanel();
        }

        $toggle.addEventListener('click', (e) => {
          e.stopPropagation();
          togglePanel();
        });
        $close.addEventListener('click', (e) => {
          e.stopPropagation();
          closePanel();
        });
        $panel.addEventListener('click', (e) => e.stopPropagation());
        document.addEventListener('click', (e) => {
          if ($panel.classList.contains('open')) {
            const inside =
              e.target === $panel ||
              $panel.contains(e.target) ||
              e.target === $toggle;
            if (!inside) closePanel();
          }
        });
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && $panel.classList.contains('open'))
            closePanel();
        });

        // html2canvas 렌더링 시 제외할 요소
        const ignoreElements = (node) => {
          if (!(node instanceof Element)) return false;
          const id = node.id || '';
          if (/^(memory|letter|wishlist)-(panel|toggle)$/.test(id)) return true;
          if (id === 'pageFade') return true;
          if (id === 'bgm-toggle') return true;
          if (node.tagName === 'AUDIO') return true;
          return false;
        };

        function timestampName(prefix = 'memory') {
          const d = new Date();
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, '0');
          const day = String(d.getDate()).padStart(2, '0');
          const hh = String(d.getHours()).padStart(2, '0');
          const mm = String(d.getMinutes()).padStart(2, '0');
          const ss = String(d.getSeconds()).padStart(2, '0');
          return `${prefix}_${y}${m}${day}_${hh}${mm}${ss}.png`;
        }

        $capBtn.addEventListener('click', async () => {
          if (typeof html2canvas !== 'function') {
            alert(
              '캡쳐 라이브러리가 아직 로드되지 않았어요. 잠시 후 다시 시도해주세요.'
            );
            return;
          }

          // 캡쳐 순간, 패널/토글 숨김
          const toHide = [$panel, $toggle];
          toHide.forEach((el) => el && el.classList.add('capture-hide'));

          try {
            // 뷰포트만 정확히 크롭해서 캡쳐
            const canvas = await html2canvas(document.body, {
              // 화면에 보이는 영역 크기
              width: window.innerWidth,
              height: window.innerHeight,

              // 현재 스크롤 위치만큼 원본을 반대로 이동시켜 "보이는 화면"을 0,0에 놓기
              scrollX: -window.scrollX,
              scrollY: -window.scrollY,

              // 클론 윈도우 자체도 뷰포트 크기로
              windowWidth: window.innerWidth,
              windowHeight: window.innerHeight,

              scale: window.devicePixelRatio || 2,
              useCORS: true,
              allowTaint: false,
              backgroundColor: null,
              ignoreElements,
            });

            if (canvas.toBlob) {
              canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = timestampName('today');
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                setMeta('이미지 저장됨');
              }, 'image/png');
            } else {
              // fallback
              const url = canvas.toDataURL('image/png');
              const a = document.createElement('a');
              a.href = url;
              a.download = timestampName('today');
              document.body.appendChild(a);
              a.click();
              a.remove();
              setMeta('이미지 저장됨');
            }
          } catch (e) {
            setMeta('캡쳐 실패');
          } finally {
            toHide.forEach((el) => el && el.classList.remove('capture-hide'));
          }
        });
      })();

      // ===== BGM 토글 (birthdaybgm) =====
      (() => {
        const $btn = document.getElementById('bgm-toggle');
        const bgm = window.birthdaybgm; // <audio id="birthdaybgm">

        if (!$btn || !bgm) return;

        function isOn() {
          return !bgm.paused && !bgm.muted && bgm.currentTime >= 0;
        }
        function updateUI() {
          const on = isOn();
          $btn.textContent = on ? '🔊 BGM 끄기' : '🔇 BGM 켜기';
          $btn.setAttribute('aria-pressed', on ? 'true' : 'false');
        }

        $btn.addEventListener('click', async () => {
          try {
            if (bgm.paused || bgm.muted) {
              bgm.muted = false;
              await bgm.play();
            } else {
              bgm.pause();
            }
          } catch (e) {
            // 모바일 정책 등으로 재생 실패 시 한 번 더 무음 재생 시도
            try {
              bgm.muted = true;
              await bgm.play();
              bgm.muted = false;
            } catch {}
          } finally {
            updateUI();
          }
        });

        // 오디오 상태 변화에 따라 버튼 텍스트 동기화
        ['play', 'pause', 'volumechange', 'ended'].forEach((ev) =>
          bgm.addEventListener(ev, updateUI)
        );

        updateUI();
      })();
    </script>
  </body>
</html>
